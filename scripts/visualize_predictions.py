"""
Visualize Predictions on GPS Heatmap
=====================================

Creates GPS heatmaps from prediction CSV files generated by main.py

Usage:
    python3 visualize_predictions.py predictions_20cm_20251216_143022.csv
"""

import pandas as pd
import numpy as np
import argparse
import re
from pathlib import Path
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.interpolate import griddata
from sklearn.metrics import mean_absolute_error, r2_score

sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (14, 10)


def extract_info_from_filename(filename: str):
    """Extract depth and model info from filename"""
    # Try to extract depth (e.g., predictions_20cm_timestamp.csv)
    depth_match = re.search(r'(\d+)cm', filename)
    depth_cm = int(depth_match.group(1)) if depth_match else None

    # Model type is harder to extract from filename, default to 'unknown'
    model_type = 'model'

    return depth_cm, model_type


def create_heatmap_from_predictions(predictions_file: str, depth_cm: int = None, model_type: str = None):
    """Create GPS heatmap from predictions CSV file"""

    # Try to extract info from filename if not provided
    if depth_cm is None or model_type is None:
        extracted_depth, extracted_model = extract_info_from_filename(predictions_file)
        if depth_cm is None:
            depth_cm = extracted_depth
        if model_type is None:
            model_type = extracted_model

    print(f"\nLoading predictions from {predictions_file}...")
    if depth_cm:
        print(f"Depth: {depth_cm}cm")
    if model_type:
        print(f"Model: {model_type}")

    # Load predictions file
    df = pd.read_csv(predictions_file)

    # Extract data
    predictions = df['predicted_shear_strength_kpa'].values
    classifications = df['classification_code'].values

    # Check if we have actual values
    has_actual = 'actual_shear_strength_kpa' in df.columns
    if has_actual:
        actual_values = df['actual_shear_strength_kpa'].values
    else:
        actual_values = None
        print("\nNote: No actual values available (prediction-only mode)")

    # Find GPS columns
    lat_col = None
    lon_col = None

    for col in ['vna_latitude', 'latitude']:
        if col in df.columns:
            lat_col = col
            break

    for col in ['vna_longitude', 'longitude']:
        if col in df.columns:
            lon_col = col
            break

    if lat_col is None or lon_col is None:
        raise ValueError(f"Could not find GPS coordinates in file")

    print(f"Using coordinates: X={lon_col}, Y={lat_col}")

    # Extract coordinates
    x = df[lon_col].values
    y = df[lat_col].values

    # Remove NaN values
    if has_actual:
        valid_mask = ~(np.isnan(x) | np.isnan(y) | np.isnan(predictions) | np.isnan(actual_values))
    else:
        valid_mask = ~(np.isnan(x) | np.isnan(y) | np.isnan(predictions))

    x = x[valid_mask]
    y = y[valid_mask]
    predictions = predictions[valid_mask]
    classifications = classifications[valid_mask]

    if has_actual:
        actual_values = actual_values[valid_mask]

    print(f"Valid points: {len(x)}")
    print(f"  Water (predicted): {np.sum(classifications == 0)} ({np.sum(classifications == 0)/len(x)*100:.1f}%)")
    print(f"  Mud (predicted): {np.sum(classifications == 1)} ({np.sum(classifications == 1)/len(x)*100:.1f}%)")

    # Create figure
    if has_actual:
        fig, axes = plt.subplots(1, 3, figsize=(22, 7))
    else:
        fig, axes = plt.subplots(1, 1, figsize=(8, 7))
        axes = [axes]

    # Determine color scale (fixed to physical limits)
    vmin = 0
    vmax = 120  # Physical upper limit for typical shear strength measurements

    # Create interpolation grid
    grid_resolution = 100
    xi = np.linspace(x.min(), x.max(), grid_resolution)
    yi = np.linspace(y.min(), y.max(), grid_resolution)
    xi, yi = np.meshgrid(xi, yi)

    # Plot 1: Predictions
    zi_pred = griddata((x, y), predictions, (xi, yi), method='linear')
    zi_pred = np.clip(zi_pred, vmin, vmax)  # Clip to physical range

    im = axes[0].contourf(xi, yi, zi_pred, levels=15, cmap='RdYlGn_r', 
                          vmin=vmin, vmax=vmax, alpha=0.8)

    # Mark water vs mud with different markers
    water_mask = classifications == 0
    mud_mask = classifications == 1

    if np.sum(water_mask) > 0:
        axes[0].scatter(x[water_mask], y[water_mask], c=predictions[water_mask], 
                       s=100, cmap='RdYlGn_r', vmin=vmin, vmax=vmax,
                       marker='o', edgecolors='blue', linewidths=2, label='Water')
    if np.sum(mud_mask) > 0:
        axes[0].scatter(x[mud_mask], y[mud_mask], c=predictions[mud_mask],
                       s=100, cmap='RdYlGn_r', vmin=vmin, vmax=vmax,
                       marker='s', edgecolors='black', linewidths=2, label='Mud')

    axes[0].set_xlabel('Longitude')
    axes[0].set_ylabel('Latitude')
    title = f'Predicted Shear Strength'
    if depth_cm:
        title += f' at {depth_cm}cm'
    title += '\n(○=Water, □=Mud)'
    axes[0].set_title(title)
    axes[0].grid(True, alpha=0.3)
    axes[0].legend()

    cbar = plt.colorbar(im, ax=axes[0])
    cbar.set_label('Shear Strength (kPa)', rotation=270, labelpad=20)

    if has_actual:
        # Plot 2: Actual values
        zi_actual = griddata((x, y), actual_values, (xi, yi), method='linear')
        zi_actual = np.clip(zi_actual, vmin, vmax)  # Clip to physical range
        
        im = axes[1].contourf(xi, yi, zi_actual, levels=15, cmap='RdYlGn_r', 
                             vmin=vmin, vmax=vmax, alpha=0.8)
        axes[1].scatter(x, y, c=actual_values, s=100, cmap='RdYlGn_r',
                       edgecolors='black', linewidths=1.5, vmin=vmin, vmax=vmax)
        axes[1].set_xlabel('Longitude')
        axes[1].set_ylabel('Latitude')
        title = f'Actual Shear Strength'
        if depth_cm:
            title += f' at {depth_cm}cm'
        title += '\n(Ground Truth)'
        axes[1].set_title(title)
        axes[1].grid(True, alpha=0.3)

        cbar = plt.colorbar(im, ax=axes[1])
        cbar.set_label('Shear Strength (kPa)', rotation=270, labelpad=20)

        # Plot 3: Prediction errors
        errors = predictions - actual_values
        error_max = 60  # Maximum reasonable error

        zi_error = griddata((x, y), errors, (xi, yi), method='linear')
        zi_error = np.clip(zi_error, -error_max, error_max)  # Clip error interpolation

        im = axes[2].contourf(xi, yi, zi_error, levels=15, cmap='RdBu_r',
                             vmin=-error_max, vmax=error_max, alpha=0.8)

        # Different markers for water vs mud
        if np.sum(water_mask) > 0:
            axes[2].scatter(x[water_mask], y[water_mask], c=errors[water_mask],
                          s=100, cmap='RdBu_r', vmin=-error_max, vmax=error_max,
                          marker='o', edgecolors='blue', linewidths=2, label='Water')
        if np.sum(mud_mask) > 0:
            axes[2].scatter(x[mud_mask], y[mud_mask], c=errors[mud_mask],
                          s=100, cmap='RdBu_r', vmin=-error_max, vmax=error_max,
                          marker='s', edgecolors='black', linewidths=2, label='Mud')
        axes[2].set_xlabel('Longitude')
        axes[2].set_ylabel('Latitude')
        title = f'Prediction Error'
        if depth_cm:
            title += f' at {depth_cm}cm'
        title += '\n(Red=Over, Blue=Under)'
        axes[2].set_title(title)
        axes[2].grid(True, alpha=0.3)
        axes[2].legend()

        cbar = plt.colorbar(im, ax=axes[2])
        cbar.set_label('Error (Predicted - Actual) (kPa)', rotation=270, labelpad=20)

    plt.tight_layout()

    # Save figure
    filename_base = Path(predictions_file).stem
    output_file = f"heatmap_{filename_base}.png"
    plt.savefig(output_file, dpi=150, bbox_inches='tight')
    print(f"\nSaved heatmap: {output_file}")
    plt.close()

    # Print statistics
    print("\n" + "="*70)
    title_parts = []
    if model_type:
        title_parts.append(f"{model_type.upper()} Model")
    if depth_cm:
        title_parts.append(f"{depth_cm}cm")

    if has_actual:
        mae = mean_absolute_error(actual_values, predictions)
        r2 = r2_score(actual_values, predictions)

        print(f"\nOverall Performance:")
        print(f"  MAE: {mae:.2f} kPa")
        print(f"  R²: {r2:.3f}")

        if np.sum(mud_mask) > 0:
            mae_mud = mean_absolute_error(actual_values[mud_mask], predictions[mud_mask])
            r2_mud = r2_score(actual_values[mud_mask], predictions[mud_mask])
            print(f"\nMud Samples Only:")
            print(f"  MAE: {mae_mud:.2f} kPa")
            print(f"  R²: {r2_mud:.3f}")

    print("\n" + "="*70)
    print("Visualization Complete!")


def main():
    """Main entry point"""

    parser = argparse.ArgumentParser(
        description='Visualize predictions on GPS heatmap',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
        Examples:
            python3 visualize_predictions.py predictions_20cm_20s251216_143022.csv
            python3 visualize_predictions.py predictions_50cm_20251216_143055.csv
            python3 visualize_predictions.py predictions_80cm_20251216_143120.csv
        """
    )

    parser.add_argument(
        'predictions_file',
        type=str,
        help='Path to predictions CSV file (from main.py output)'
    )

    args = parser.parse_args()

    # Check if file exists
    if not Path(args.predictions_file).exists():
        print(f"Error: File not found: {args.predictions_file}")
        return

    # Create heatmap (depth and model will be extracted from filename)
    create_heatmap_from_predictions(args.predictions_file)


if __name__ == "__main__":
    main()
